// Copyright 2020 Open Whisper Systems
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
//  See the License for the specific language governing permissions and
//  limitations under the License.

use bindgen::Bindings;
use clap::{App, Arg};
use proc_macro2::token_stream::TokenStream;
use quote::quote;
use std::env;
use std::io::Write;
use std::process::{Command, ExitStatus, Stdio};
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::{FnArg, ForeignItem, ForeignItemFn, ItemForeignMod, Pat, Token, UseTree};

fn main() -> anyhow::Result<(), anyhow::Error> {
    let args: Vec<_> = env::args().collect();

    let config = parse_args(args)?;
    let jniimpl_module = syn::parse_str::<UseTree>(config.jniimpl_module.as_str())?;
    let bindings = run_bindgen(config.header_file, config.clang_args)?;
    let tokens = bindings.to_string().parse::<TokenStream>().map_err(|e| {
        anyhow::Error::msg(format!(
            "parsing rust AST of bindgen output failed: {:?}",
            e
        ))
    })?;

    let fancy = syn::parse2::<FancyParse>(tokens)?;

    let func_defs: Vec<TokenStream> = fancy
        .funcs
        .into_iter()
        .map(|func: ForeignItemFn| add_func_body(func))
        .collect();
    let prefix = quote! {
        // Generated by jbindgen

        use jni::*;
        use jni::sys::*;
        use #jniimpl_module::JniImpl;
    }
    .to_string();

    let mut pieces = vec![prefix];
    for func in func_defs {
        pieces.push(func.to_string());
    }
    let out = pieces.join("\n\n");

    run_rustfmt(out)?;
    return Ok(());
}

#[derive(Default)]
struct Config {
    header_file: String,
    jniimpl_module: String,
    clang_args: Vec<String>,
}

fn parse_args(args: Vec<String>) -> anyhow::Result<Config> {
    let matches = App::new("jbindgen")
        .about("Generates Rust code from Java JNI headers")
        .usage("jbindgen [FLAGS] [OPTIONS] <header> -- <clang-args>...")
        .args(&[
            Arg::with_name("header")
                .help("Java JNI C or C++ header")
                .required(true),
            Arg::with_name("jniimpl_module")
                .help(
                    "module to find the JniImpl struct definition that the generated functions \
                will expect a matching method on",
                )
                .long("jniimpl_module")
                .default_value("jniimpl")
                .required(true),
            // All positional arguments after the end of options marker, `--`
            Arg::with_name("clang-args").last(true).multiple(true),
        ])
        .get_matches_from(args);

    let header_file = matches
        .value_of("header")
        .map(|h| h.to_string())
        .ok_or(anyhow::Error::msg("header argument wasn't given."))?;

    let jniimpl_module = matches
        .value_of("jniimpl_module")
        .map(|m| m.to_string())
        .ok_or(anyhow::Error::msg("jniimpl_module argument wasn't given."))?;

    let clang_args: Vec<String> = matches
        .values_of("clang-args")
        .map(|v| v.map(|s| s.to_string()).collect())
        .unwrap_or(vec![]);

    return Ok(Config {
        header_file: header_file,
        jniimpl_module: jniimpl_module,
        clang_args: clang_args,
    });
}

struct FancyParse {
    funcs: Vec<ForeignItemFn>,
}

impl Parse for FancyParse {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut funcs: Vec<ForeignItemFn> = vec![];
        while !input.is_empty() {
            let forn_mod = input.parse::<ItemForeignMod>()?;
            let fs: Vec<ForeignItemFn> = forn_mod
                .items
                .into_iter()
                .filter_map(|item| match item {
                    ForeignItem::Fn(f) => Some(f),
                    _ => None,
                })
                .collect();
            funcs.extend(fs);
        }
        Ok(FancyParse { funcs: funcs })
    }
}

// Runs bindgen and only generate the `Java_` functions.
fn run_bindgen(header_file: String, clang_args: Vec<String>) -> Result<Bindings, anyhow::Error> {
    return bindgen::builder()
        .header(header_file)
        .whitelist_function("Java_.*")
        .with_codegen_config(bindgen::CodegenConfig::FUNCTIONS)
        .clang_args(clang_args)
        .generate()
        .map_err(|_| anyhow::Error::msg("bindgen failed but won't say how"));
}

// Turns the extern functions bindgen generated from the C header file (which was generated by
// javac) into full-fledged functions by giving them bodies. Those bodies call out to an
// non-existent `FakeType` that the user of jbindgen is expected to implement.
fn add_func_body(func: ForeignItemFn) -> TokenStream {
    let sig = func.sig.clone();
    let fn_name = sig.clone().ident;
    let inputs: Vec<Box<Pat>> = func
        .sig
        .clone()
        .inputs
        .into_iter()
        .filter_map(|input| match input {
            FnArg::Typed(pat_type) => Some(pat_type.pat),
            _ => None,
        })
        .collect();

    let mut commaed: Punctuated<Box<Pat>, Token![,]> = Punctuated::new();
    for pat in inputs.into_iter() {
        commaed.push(pat);
    }
    return quote! {
      #[no_mangle]
      #sig {
        return JniImpl{}.#fn_name(#commaed)
      }
    };
}

// run_rustfmt runs the rustfmt binary on the Rust code we generated, and prints the formatted
// code to stdout immediately.
fn run_rustfmt(gen_code: String) -> Result<ExitStatus, anyhow::Error> {
    let mut fmt_cmd = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .stdin(Stdio::piped())
        .spawn()?;
    let stdin = fmt_cmd
        .stdin
        .as_mut()
        .ok_or(anyhow::Error::msg("Couldn't access stdin"))?;
    stdin.write_all(gen_code.to_string().as_bytes())?;
    return fmt_cmd.wait().map_err(|e| anyhow::Error::new(e));
}
