// Copyright 2020 Open Whisper Systems
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
//  See the License for the specific language governing permissions and
//  limitations under the License.

use bindgen::Bindings;
use clap::{App, Arg};
use proc_macro2::token_stream::TokenStream;
use proc_macro2::{Ident, Span};
use quote::quote;
use std::borrow::Borrow;
use std::io::Write;
use std::process::{Command, ExitStatus, Stdio};
use std::{env, mem};
use syn::fold::Fold;
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::{
    AngleBracketedGenericArguments, FnArg, ForeignItem, ForeignItemFn, GenericParam,
    ItemForeignMod, LifetimeDef, Pat, PathArguments, PathSegment, ReturnType, Token, Type,
    TypePath, UseTree,
};

fn main() -> anyhow::Result<(), anyhow::Error> {
    let lifetime_args = syn::parse_str::<AngleBracketedGenericArguments>("<'a>")?;

    let args: Vec<_> = env::args().collect();

    let config = parse_args(args)?;
    let jniimpl_use = syn::parse_str::<UseTree>(config.jniimpl_use.as_str())?;
    let bindings = run_bindgen(config.header_file, config.clang_args)?;
    let tokens = bindings.to_string().parse::<TokenStream>().map_err(|e| {
        anyhow::Error::msg(format!(
            "parsing rust AST of bindgen output failed: {:?}",
            e
        ))
    })?;

    let funcs = syn::parse2::<JNIFuncParse>(tokens)?.funcs;
    let includes_methods = funcs.iter().any(|func| {
        func.sig.inputs.iter().any(|arg| match arg {
            FnArg::Receiver(_) => true,
            _ => false,
        })
    });
    if includes_methods {
        return Err(anyhow::Error::msg(
            "Generated Rust JNI code included a method, which isn't supported",
        ));
    }
    let func_defs: Vec<TokenStream> = funcs
        .into_iter()
        .map(|func: ForeignItemFn| add_func_body(func, jniimpl_use.clone(), lifetime_args.clone()))
        .collect();

    let prefix = quote! {
        use jni::JNIEnv;
        #[allow(unused_imports)]
        use jni::sys::*;
        #[allow(unused_imports)]
        use jni::objects::{JClass, JFieldID, JMethodID, JObject, JStaticFieldID, JString,
        JThrowable, JValue};
    }
    .to_string();

    let mut pieces = vec!["// Generated by jbindgen".to_string(), prefix];
    for func in func_defs {
        pieces.push(func.to_string());
    }
    let out = pieces.join("\n\n");

    run_rustfmt(out)?;
    return Ok(());
}

struct Config {
    header_file: String,
    jniimpl_use: String,
    clang_args: Vec<String>,
}

fn parse_args(args: Vec<String>) -> anyhow::Result<Config> {
    let matches = App::new("jbindgen")
        .about("Generates Rust code from Java JNI headers")
        .usage("jbindgen [FLAGS] [OPTIONS] <header> -- <clang-args>...")
        .args(&[
            Arg::with_name("header")
                .help("Java JNI C or C++ header")
                .required(true),
            Arg::with_name("jniimpl_use")
                .help(
                    "The full use path to the module containing the function definitions that match the JNI generated functions.",
                )
                .long("jniimpl_use")
                .default_value("crate::jniimpl")
                .required(true),
            // All positional arguments after the end of options marker, `--`
            Arg::with_name("clang-args").last(true).multiple(true),
        ])
        .get_matches_from(args);

    let header_file = matches
        .value_of("header")
        .map(|h| h.to_string())
        .ok_or(anyhow::Error::msg("header argument wasn't given."))?;

    let jniimpl_use = matches
        .value_of("jniimpl_use")
        .map(|m| m.to_string())
        .ok_or(anyhow::Error::msg("jniimpl_use argument wasn't given."))?;

    let clang_args: Vec<String> = matches
        .values_of("clang-args")
        .map(|v| v.map(|s| s.to_string()).collect())
        .unwrap_or(vec![]);

    return Ok(Config {
        header_file: header_file,
        jniimpl_use: jniimpl_use,
        clang_args: clang_args,
    });
}

struct JNIFuncParse {
    funcs: Vec<ForeignItemFn>,
}

impl Parse for JNIFuncParse {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut funcs: Vec<ForeignItemFn> = vec![];
        while !input.is_empty() {
            let forn_mod = input.parse::<ItemForeignMod>()?;
            let fs: Vec<ForeignItemFn> = forn_mod
                .items
                .into_iter()
                .filter_map(|item| match item {
                    ForeignItem::Fn(f) => Some(f),
                    _ => None,
                })
                .collect();
            funcs.extend(fs);
        }
        Ok(JNIFuncParse { funcs: funcs })
    }
}

/// Runs bindgen and only generates the `Java_` functions.
fn run_bindgen(header_file: String, clang_args: Vec<String>) -> Result<Bindings, anyhow::Error> {
    return bindgen::builder()
        .header(header_file)
        .whitelist_function("Java_.*")
        .with_codegen_config(bindgen::CodegenConfig::FUNCTIONS)
        .clang_args(clang_args)
        .generate()
        .map_err(|_| anyhow::Error::msg("bindgen failed but won't say how"));
}

/// add_func_body turns the extern functions bindgen generated from the C header file (which was
/// generated by javac) into full-fledged functions by giving them bodies. Those bodies call out to
/// a non-existent `FakeType` that the user of jbindgen is expected to implement.
fn add_func_body(
    func: ForeignItemFn,
    jniimpl_use: UseTree,
    lifetime_args: AngleBracketedGenericArguments,
) -> TokenStream {
    let mut sig = RewriteSysTypes {
        lifetime_args: lifetime_args,
    }
    .fold_signature(func.sig);
    let generics = lifetime_generics();
    mem::replace(&mut sig.generics, generics);

    let fn_name = sig.ident.clone();
    let inputs: Vec<Box<Pat>> = sig
        .inputs
        .clone()
        .into_iter()
        .filter_map(|input| match input {
            FnArg::Typed(pat_type) => Some(pat_type.pat),
            _ => None,
        })
        .collect();

    let mut commaed: Punctuated<Box<Pat>, Token![,]> = Punctuated::new();
    for pat in inputs.into_iter() {
        commaed.push(pat);
    }
    return quote! {
      #[allow(non_snake_case)]
      #[no_mangle]
      #sig {
        return #jniimpl_use::#fn_name(#commaed)
      }
    };
}

/// RewriteSysTypes turns `jni::sys` equivalent types that bindgen creates into
/// `jni::objects` equivalent types (e.g. `jclass` becomes `JClass`) that contain
/// lifetimes.
struct RewriteSysTypes {
    lifetime_args: AngleBracketedGenericArguments,
}

impl RewriteSysTypes {
    fn with_lifetime(&mut self, new_name: &str, ident: Ident) -> PathSegment {
        return PathSegment {
            ident: Ident::new(new_name, ident.span()),
            arguments: PathArguments::AngleBracketed(self.lifetime_args.clone()),
        };
    }

    fn is_jnienv(&mut self, path: &TypePath) -> bool {
        let length = path.path.segments.len();
        if length != 1 {
            return false;
        }
        return path
            .path
            .segments
            .first()
            .map_or(false, |e| e.ident.to_string().as_str() == "JNIEnv");
    }
}

impl Fold for RewriteSysTypes {
    fn fold_path_segment(&mut self, segment: PathSegment) -> PathSegment {
        return match segment.ident.to_string().as_str() {
            "jclass" => self.with_lifetime("JClass", segment.ident),
            "jfieldid" => self.with_lifetime("JFieldID", segment.ident),
            "jmethodid" => self.with_lifetime("JMethodID", segment.ident),
            "jobject" => self.with_lifetime("JObject", segment.ident),
            "jstaticfieldid" => self.with_lifetime("JStaticFieldID", segment.ident),
            "jstring" => self.with_lifetime("JString", segment.ident),
            "jthrowable" => self.with_lifetime("JThrowable", segment.ident),
            "jvalue" => self.with_lifetime("JValue", segment.ident),
            _ => segment,
        };
    }

    fn fold_type(&mut self, typ: Type) -> Type {
        match typ.borrow() {
            Type::Ptr(type_ptr) => match type_ptr.elem.borrow() {
                syn::Type::Path(path) => {
                    if self.is_jnienv(path) {
                        return Type::Path(path.clone().into());
                    }
                }
                _ => {}
            },
            _ => {}
        }
        return syn::fold::fold_type(self, typ);
    }

    fn fold_return_type(&mut self, ret: ReturnType) -> ReturnType {
        // Don't rewrite any of the primitive jni::sys types in the return types of the functions.
        return ret;
    }
}

fn lifetime_generics() -> syn::Generics {
    let mut p: Punctuated<GenericParam, Token![,]> = Punctuated::new();
    let def = LifetimeDef {
        attrs: vec![],
        lifetime: syn::Lifetime {
            apostrophe: Span::call_site(),
            ident: Ident::new("a", Span::call_site()),
        },
        colon_token: Some(syn::token::Colon(Span::call_site())),
        bounds: Default::default(),
    };
    p.push(GenericParam::Lifetime(def));
    syn::Generics {
        lt_token: Some(syn::token::Lt(Span::call_site())),
        params: p,
        gt_token: Some(syn::token::Gt(Span::call_site())),
        where_clause: None,
    }
}

/// run_rustfmt runs the rustfmt binary on the Rust code we generated, and prints the formatted
/// code to stdout immediately.
fn run_rustfmt(gen_code: String) -> Result<ExitStatus, anyhow::Error> {
    let mut fmt_cmd = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .stdin(Stdio::piped())
        .spawn()?;
    let stdin = fmt_cmd
        .stdin
        .as_mut()
        .ok_or(anyhow::Error::msg("Couldn't access stdin"))?;
    stdin.write_all(gen_code.to_string().as_bytes())?;
    return fmt_cmd.wait().map_err(|e| anyhow::Error::new(e));
}
