// Copyright 2020 Open Whisper Systems
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
//  See the License for the specific language governing permissions and
//  limitations under the License.

use bindgen::Bindings;
use proc_macro2::token_stream::TokenStream;
use quote::quote;
use std::io;
use std::io::Read;
use std::io::Write;
use std::process::{Command, ExitStatus, Stdio};
use syn::parse::{Parse, ParseStream};
use syn::punctuated::Punctuated;
use syn::{FnArg, ForeignItem, ForeignItemFn, ItemForeignMod, Pat, Token};

fn main() -> anyhow::Result<(), anyhow::Error> {
    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;
    let bindings = run_bindgen(buffer)?;
    let tokens = bindings.to_string().parse::<TokenStream>().map_err(|e| {
        anyhow::Error::msg(format!(
            "parsing rust AST of bindgen output failed: {:?}",
            e
        ))
    })?;

    let fancy = syn::parse2::<FancyParse>(tokens)?;

    let func_defs: Vec<TokenStream> = fancy
        .funcs
        .into_iter()
        .map(|func: ForeignItemFn| add_func_body(func))
        .collect();
    let gen_comment = format!(
        "// Generated by jbindgen on {}\n\n",
        chrono::Utc::now().date()
    );
    let uses = quote! {
        use jni::*;
        use jni::sys::*;
    }
    .to_string();

    let mut pieces = vec![gen_comment, uses];
    for func in func_defs {
        pieces.push(func.to_string());
    }
    let out = pieces.join("\n\n");

    run_rustfmt(out)?;
    return Ok(());
}

struct FancyParse {
    funcs: Vec<ForeignItemFn>,
}

impl Parse for FancyParse {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut funcs: Vec<ForeignItemFn> = vec![];
        while !input.is_empty() {
            let forn_mod = input.parse::<ItemForeignMod>()?;
            let fs: Vec<ForeignItemFn> = forn_mod
                .items
                .into_iter()
                .filter_map(|item| match item {
                    ForeignItem::Fn(f) => Some(f),
                    _ => None,
                })
                .collect();
            funcs.extend(fs);
        }
        Ok(FancyParse { funcs: funcs })
    }
}

// Runs bindgen and only generate the `Java_` functions.
fn run_bindgen(c_header_contents: String) -> Result<Bindings, anyhow::Error> {
    return bindgen::builder()
        .header_contents("rust_jni.h", &c_header_contents)
        .whitelist_function("Java_.*")
        .with_codegen_config(bindgen::CodegenConfig::FUNCTIONS)
        // FIXME makes these trailing args
        .clang_arg("-I/usr/lib/jvm/java-11-openjdk-amd64/include/")
        .clang_arg("-I/usr/lib/jvm/java-11-openjdk-amd64/include/linux/")
        .generate()
        .map_err(|_| anyhow::Error::msg("bindgen failed but won't say how"));
}

// Turns the extern functions bindgen generated from the C header file (which was generated by
// javac) into full-fledged functions by giving them bodies. Those bodies call out to an
// non-existent `FakeType` that the user of jbindgen is expected to implement.
fn add_func_body(func: ForeignItemFn) -> TokenStream {
    let sig = func.sig.clone();
    let fn_name = sig.clone().ident;
    let inputs: Vec<Box<Pat>> = func
        .sig
        .clone()
        .inputs
        .into_iter()
        .filter_map(|input| match input {
            FnArg::Typed(pat_type) => Some(pat_type.pat),
            _ => None,
        })
        .collect();

    let mut commaed: Punctuated<Box<Pat>, Token![,]> = Punctuated::new();
    for pat in inputs.into_iter() {
        commaed.push(pat);
    }
    return quote! {
      #[no_mangle]
      #sig {
        return FakeType{}.#fn_name(#commaed)
      }
    };
}

// run_rustfmt runs the rustfmt binary on the Rust code we generated, and prints the formatted
// code to stdout immediately.
fn run_rustfmt(gen_code: String) -> Result<ExitStatus, anyhow::Error> {
    let mut fmt_cmd = Command::new("rustfmt")
        .arg("--emit")
        .arg("stdout")
        .stdin(Stdio::piped())
        .spawn()?;
    let stdin = fmt_cmd
        .stdin
        .as_mut()
        .ok_or(anyhow::Error::msg("Couldn't access stdin"))?;
    stdin.write_all(gen_code.to_string().as_bytes())?;
    return fmt_cmd.wait().map_err(|e| anyhow::Error::new(e));
}
